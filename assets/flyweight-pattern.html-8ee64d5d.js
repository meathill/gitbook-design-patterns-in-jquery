import{_ as c,r as t,o as i,c as l,a as n,b as s,d as a,e as o}from"./app-df1eeafe.js";const r={},u=n("h1",{id:"享元模式",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#享元模式","aria-hidden":"true"},"#"),s(" 享元模式")],-1),d=n("blockquote",null,[n("p",null,"Flyweight Pattern，享元模式，属于结构型模式。")],-1),k=n("blockquote",null,[n("p",null,"因为 jQuery 使用组合模式作为其 API 的基础，所以享元模式也被大量使用，尤其在插件开发时。")],-1),v={href:"https://getbootstrap.com/docs/4.3/components/modal/#via-javascript",target:"_blank",rel:"noopener noreferrer"},h=o(`<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">&#39;#myModal&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">modal</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样可以把 <code>id</code> 为 <code>myModel</code> 的 DOM 实例化成一个弹窗。前面的选择器可以是 <code>id</code>，也可以是 <code>class</code>，找到的 DOM 节点都会被作为弹窗处理。</p><h2 id="优势" tabindex="-1"><a class="header-anchor" href="#优势" aria-hidden="true">#</a> 优势</h2><p>在网页里，存在大量相似的节点，它们功能一致，结构相似。如果我们针对每个节点都创建一个独立的功能对象，将消耗大量的系统资源。这个时候，我们可以把相似的节点交给一个享元对象处理，它们的外部数据都通过享元对象存储和提取。避免极为类似的数据存储多份浪费空间。</p><h2 id="功能介绍" tabindex="-1"><a class="header-anchor" href="#功能介绍" aria-hidden="true">#</a> 功能介绍</h2><p>享元模式一般有一个享元对象，还有若干元素对象。元素对象的外部状态应该是一致的，然后搬运到享元对象，然后从元素对象中删除。</p><p>接下来的操作，应该避免访问某个特定的元素对象，都交给享元对象处理。</p><p>如果某个元素需要独立变化，那么最好把它移出之前的享元对象，然后创建新的享元对象并放入。</p><h2 id="jquery-实现" tabindex="-1"><a class="header-anchor" href="#jquery-实现" aria-hidden="true">#</a> jQuery 实现</h2>`,9),m={href:"https://learn.jquery.com/plugins/basic-plugin-creation/",target:"_blank",rel:"noopener noreferrer"},b=o(`<ol><li>单一环境中大量使用</li><li>外部状态非常相似</li><li>方便批量处理</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span> <span class="token parameter">$</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>

  $<span class="token punctuation">.</span>fn<span class="token punctuation">.</span><span class="token function-variable function">greenify</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span> <span class="token parameter">options</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">// 处理插件参数，这些参数，无论包含什么样的内容，都只存在一份</span>
    <span class="token comment">// 可以在元素间共享，只占用一份空间</span>
    <span class="token keyword">var</span> settings <span class="token operator">=</span> $<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">color</span><span class="token operator">:</span> <span class="token string">&quot;#556b2f&quot;</span><span class="token punctuation">,</span>
      <span class="token literal-property property">backgroundColor</span><span class="token operator">:</span> <span class="token string">&quot;white&quot;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> options <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 使用 \`.each\` 处理所有插件</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token literal-property property">color</span><span class="token operator">:</span> settings<span class="token punctuation">.</span>color<span class="token punctuation">,</span>
        <span class="token literal-property property">backgroundColor</span><span class="token operator">:</span> settings<span class="token punctuation">.</span>backgroundColor
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span><span class="token punctuation">(</span> jQuery <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="javascript-和经典模式的区别" tabindex="-1"><a class="header-anchor" href="#javascript-和经典模式的区别" aria-hidden="true">#</a> JavaScript 和经典模式的区别</h2><p>经典模式里，数据结构和垃圾回收都是值得关注的内容。但是在 JS 里，这两方面都不受我们控制。JS 里所有东西都是对象，我们对 Web 的操作会由浏览器映射到屏幕上，所以大部分时候，我们要关注的是数据的引用和处理。</p>`,4),_=n("h2",{id:"适用性",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#适用性","aria-hidden":"true"},"#"),s(" 适用性")],-1),f=n("p",null,"当你遇到类似下面的需求，应该考虑使用享元模式：",-1),y=n("ol",null,[n("li",null,"使用大量对象"),n("li",null,"如果对每个对象初始化，可能造成大量的内存浪费"),n("li",null,"这些对象大部分状态是外部状态，或者说可以通过外部访问"),n("li",null,"这些对象的外部对象基本都一致，可以共享"),n("li",null,"对象本身不需要被个体识别")],-1);function g(j,x){const e=t("ExternalLinkIcon"),p=t("adsense");return i(),l("div",null,[u,d,k,n("p",null,[s("jQuery 成功的地方，还在于它提供了非常好的插件体系，很多常用的功能都可以通过插件实现，复用性非常强，用法非常简单。比如在著名前端框架 Bootstrap 中，就大量使用这种插件，比如 "),n("a",v,[s("弹窗（Model）"),a(e)]),s("：")]),h,n("p",null,[s("jQuery 里面能直接体现享元模式的代码不太多，所以我摘抄 "),n("a",m,[s("jQuery 教学：如何创建插件（jQuery Learn: How to Create a Basic Plugin）"),a(e)]),s(" 里的一段范例代码。jQuery 插件其实很好的体现了享元模式的效果：")]),b,a(p),_,f,y])}const q=c(r,[["render",g],["__file","flyweight-pattern.html.vue"]]);export{q as default};
